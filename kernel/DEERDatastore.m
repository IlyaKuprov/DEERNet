% Infinite datastore of DEER data for spin-1/2 electrons. Generates 
% a new minibatch of data on-the-fly at every read request. Syntax:
%
%                  dstore=DEERDatastore(parameters)
%
% Parameters:
%
%    parameters - training database option array required 
%                 by deer_lib_gen.m
%
% Output:
%
%    dstore     - MATLAB datastore object expected by the
%                 neural network training function
%
% jake.keeley@soton.ac.uk
% 
% <https://spindynamics.org/wiki/index.php?title=DEERDatastore.m>

classdef DEERDatastore < matlab.io.Datastore & ...
                         matlab.io.datastore.MiniBatchable & ...
                         matlab.io.datastore.BackgroundDispatchable
    
    % Public datastore properties
    properties  
        
        % Number of training pairs generated in each datastore read cycle
        MiniBatchSize = 1;
        
        % Parameters structure required by deer_lib_gen
        Parameters (1,1) struct
        
    end
    
    % Protected properties inherited from superclass
    properties (SetAccess = protected, Dependent)
        
        % Number of training pairs in 1 epoch
        NumObservations
    
    end
    
    % Public datastore methods
    methods 
       
        % Constructor
        function obj=DEERDatastore(parameters)
            obj.Parameters=parameters;                
        end
        
        % Pretend we always have data
        function tf=hasdata(obj), tf=true; end %#ok<MANU>
        
        % Ignore reset command
        function reset(ds), end %#ok<MANU>
        
        % Ignore progress command
        function progress(ds), end %#ok<MANU>
        
        % Pretend we have 250 minibatches        
        function numObs=get.NumObservations(obj)
           numObs=250*obj.MiniBatchSize; 
        end
        
        % Enforce integer minibatch sizes
        function set.MiniBatchSize(obj,value)
            if ~isfinite(value) || value~=floor(value)
                error('MiniBatchSize must be an integer');
            else
                obj.MiniBatchSize=value;
            end
        end
        
        % On read requests, generate data
        function [data,info]=read(obj)
            info=struct;
            data=make_batch(obj.Parameters,obj.MiniBatchSize);
        end
        function [data,info]=readByIndex(obj,idx)
            info=struct;
            data=make_batch(obj.Parameters,numel(idx));
        end
        
    end
                     
end

% Makes a batch of training data
function data=make_batch(parameters,ntraces)

    % Specify the number of traces
    parameters.ntraces=ntraces;
    
    % Get the library
    library=deer_lib_gen('',parameters);

    % Decide noise inclusion
    if strcmp(parameters.training_input,'clean_data')
        deer_lib_slice=library.deer_clean_lib;
    elseif strcmp(parameters.training_input,'noisy_data')
        deer_lib_slice=library.deer_noisy_lib;
    else
        error('Unrecognised "training input" parameter.')
    end

    % Full dataset is generated by default
    if (~isfield(parameters,'npt_acq'))||...
       (parameters.npt_acq==parameters.np_time)

        % Question-answer pairs as a table
        data=table(num2cell(deer_lib_slice,1)',...
                   num2cell(library.dist_distr_lib,1)');

    else
        
        % Preallocation
        masked_deer_lib=zeros(parameters.npt_acq,ntraces,'single');
        mask_lib_lin=zeros(parameters.npt_acq,ntraces,'single');
        mask_lib_sqr=zeros(parameters.npt_acq,ntraces,'single');

        % Do the sampling
        for n=1:ntraces
        
            % Get a point drop mask (first and last point
            % mult always be present)
            mask=false(parameters.np_time,1);
            mask([1:(parameters.npt_acq-1) parameters.np_time])=true;
            mask=mask([1 ...                 % First element sampled
                       randperm(parameters.np_time-2)+1 ...
                       parameters.np_time]); % Last element sampled
            mask=find(mask);
        
            % Apply point drop mask
            masked_deer_lib(:,n)=deer_lib_slice(mask,n);
            mask_lib_lin(:,n)=2*(mask/512-0.5);
            mask_lib_sqr(:,n)=4*(mask/512-0.5).^2-0.5;

        end

        % Regression lego
        sparse_deer_lib=[mask_lib_lin; 
                         mask_lib_sqr;
                         masked_deer_lib;
                         masked_deer_lib.*mask_lib_lin;
                         masked_deer_lib.*mask_lib_sqr];
    
        % Question-answer pairs as a table
        data=table(num2cell(sparse_deer_lib,1)',...
                   num2cell(library.dist_distr_lib,1)');

    end

end

% "Neither the balloon, nor the aeroplane, nor the gliding machine
%  will be a practical success"
%
% Lord Kelvin, in 1902, in a press interview
% about the future of aeronautics

